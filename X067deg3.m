//X_0(67). Load searchDiv2, reduce, modeqns
load "ozmansiksek.m";

X,Z,phi,j,al,jd:=modeqns(67,1); //Takes a while.
X;
assert Genus(X) eq 5;

RR<[u]>:=CoordinateRing(AmbientSpace(X));
n:=Dimension(AmbientSpace(X));
M:=al[1];
row:=[&+[RowSequence(M)[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]];
w:=iso<X->X | row,row>; //The A-L involution w_{67}.

infcusp:=X![1,0,0,0,0]; 
assert 1/j(infcusp) eq 0; 
cusp2:=X![1/2 , 1 , 1/2 , 1/2 , 1];//
assert 1/j(cusp2) eq 0; //Indeed both are cusps.
assert cusp2 eq w(infcusp); //w acts on the cusps
Dtor:=Divisor(cusp2)-Divisor(infcusp);
assert not IsPrincipal(Dtor); //Sanity check
assert IsPrincipal(11*Dtor); //So J_0(67)(\Q)_{tor} \simeq Z/11Z.

//We now compute C and J(C)(\Q)
Cprime,projCprime:=CurveQuotient(AutomorphismGroup(X,[w]));
C,h:=SimplifiedModel(Cprime);
XtoC:=Expand(projCprime*h);
assert Genus(C) eq 2;
ptsC:=Setseq(Points(C : Bound:=1000));
J:=Jacobian(C);
assert #TorsionSubgroup(J) eq 1; //J has no torsion.
ptsJ:=[pt-ptsC[1] : pt in ptsC];
Q1:=ptsJ[2];
Q2:=ptsJ[6];
bas,M:=ReducedBasis([Q1,Q2]);
assert #bas eq 2;//This shows J(C)(\Q) has rank 2;
//We will show that Q1,Q2 are a basis using Stoll's algorithm
N:=Orthogonalize(M);
absbd:=Ceiling(Exp((N[1,1]^2+N[1,2]^2+N[2,1]^2+N[2,2]^2)/4+HeightConstant(J)));
//J(C)(\Q) is generated by P1,P2 and all points of height up to absbd.
PtsUpToAbsBound:=Points(J : Bound:=absbd);
assert ReducedBasis([pt : pt in PtsUpToAbsBound]) eq [Q2,-Q1]; //This shows Q1,Q2 are a basis.

//We use these generators to find the free generators of J_0(67)(\Q)
D1:=Pullback(XtoC,Place(ptsC[2])-Place(ptsC[1]));
D2:=Pullback(XtoC,Place(ptsC[6])-Place(ptsC[1]));
Km2<rtm2>:=QuadraticField(-2);
Km11<rtm11>:=QuadraticField(-11);
P7:=X(Km11)![ 0, 1/11*(rtm11 + 11), 1/22*(-rtm11 + 11), 1/22*(rtm11 + 11), 1 ];
P1:=X(Km2)![ 1/18*(-rtm2 + 4), 1/18*(rtm2 + 14), 1/18*(-rtm2 + 4), 1/9*(-rtm2 + 4), 1 ];
bp:=Pullback(XtoC,Place(ptsC[1]));
assert bp eq Place(infcusp)+Place(cusp2); 
assert Place(P7) - bp eq D1;
assert Place(P1) - bp eq D2; //So D1 and D2 are indeed as claimed.


//We verify the quadratic points found using the searchDiv2 function of Ozman and Siksek.
//No error means the points lie on X.
Km3<rtm3>:=QuadraticField(-3);
Km7<rtm7>:=QuadraticField(-7);
Km43<rtm43>:=QuadraticField(-43);
P0:=X(Rationals())![3/4 , 7/12 , 7/12 , 1/3 , 1]; //Non-cuspidal rational point.
P2:=X(Km3)![ 0, 1/6*(rtm3 + 3), 1/6*(rtm3 + 3), 1/6*(rtm3 + 3), 1 ];
P3:=X(Km3)![ 1/26*(3*rtm3 + 5), 1, 1/26*(-rtm3 + 7), 1/13*(rtm3 + 6), 1 ];
P4:=X(Km3)![ 1/91*(18*rtm3 + 22), 1/182*(-27*rtm3 + 149), 1/182*(15*rtm3 + 79), 1/182*(-3*rtm3 + 57), 1];
P5:=X(Km7)![ 1/16*(rtm7 + 5), 1/16*(-rtm7 + 11), 1/16*(rtm7 + 5), 1/16*(rtm7 + 5), 1 ];
P6:=X(Km7)![ 1/20*(-rtm7 + 1), 1/20*(-rtm7 + 21), 1/20*(rtm7 + 7), 1/20*(-rtm7+ 9), 1 ];
P8:=X(Km43)![ 1/106*(-rtm43 - 13), 1/53*(-2*rtm43 + 27), 1/106*(-5*rtm43 + 41), 1/53*(-2*rtm43 + 27), 1 ]; 
pls2:=[Place(P1),Place(P2),Place(P3),Place(P4),Place(P5),Place(P6),Place(P7),Place(P8)];
assert &and[XtoC(RepresentativePoint(PP)) in C(Rationals()) : PP in pls2]; //None of the points are exceptional.
ptsX:=PointSearch(X,1000);
pls1:=[Place(pt) : pt in ptsX];
assert #ptsX eq 3; //It finds the 2 cusps and P0;.
assert #ptsC eq 10; //This matches up. 
//The pair of cusps maps to 1 point in C(\Q), the extra rational pt and 8 quadratic pts to the other 9.
deg2:=[1*pl : pl in pls2] cat [1*Place(pt1) + 1*Place(pt2) : pt1 in ptsX, pt2 in ptsX];
assert &and[Pullback(XtoC,Place(pt)) in deg2 : pt in ptsC];
deg2pb:=[1*pl : pl in pls2 | XtoC(RepresentativePoint(pl)) in C(Rationals())] cat 
[1*pl1 + 1*pl2 : pl1 in pls1, pl2 in pls1 | w(RepresentativePoint(pl1)) eq RepresentativePoint(pl2)];
deg2npb:=[DD : DD in deg2 | not DD in deg2pb]; //We split deg2 into deg2 \cap XtoC*(C(\Q)) and the rest.
assert Seqset(deg2) eq Seqset(deg2pb cat deg2npb); //Sanity check.
pts:=[infcusp,cusp2,P0];
rationalpts:=[Place(c) : c in pts];
deg3pb:=Setseq({<Place(c),DD> : c in pts, DD in deg2pb});
deg3pbsum:=[DD[1]+DD[2] : DD in deg3pb];
excpls:=[Divisor(X,ideal<RR | [
    u[3]^2 - 14/11*u[3]*u[5] + 13/22*u[4]*u[5] - 1/11*u[5]^2,
    u[3]*u[4] - 8/11*u[3]*u[5] - 1/11*u[4]*u[5] + 1/11*u[5]^2,
    u[3]*u[5] - 143/6*u[4]^2 + 76/3*u[4]*u[5] - 7*u[5]^2,
    u[1] - 3*u[3] - 3*u[4] + 2*u[5],
    u[2] - u[3] - 3*u[4] + u[5]]>),
    Divisor(X,ideal<RR | [
    u[1]^2 - 13/18*u[1]*u[5] + 17/6*u[4]*u[5] - 5/3*u[5]^2,
    u[1]*u[4] - 11/18*u[1]*u[5] - 5/6*u[4]*u[5] + 2/3*u[5]^2,
    u[1]*u[5] - 18*u[4]^2 + 21*u[4]*u[5] - 6*u[5]^2,
    u[2] - u[4],
    u[3] + u[4] - u[5]]>),
    Divisor(X,ideal<RR | [
    u[3]^2 - 136/203*u[3]*u[5] + 93/203*u[4]*u[5] - 18/203*u[5]^2,
    u[3]*u[4] - 89/203*u[3]*u[5] - 69/203*u[4]*u[5] + 33/203*u[5]^2,
    u[3]*u[5] - 203/6*u[4]^2 + 89/3*u[4]*u[5] - 41/6*u[5]^2,
    u[1] - u[3],
    u[2] - 2*u[4]]>)];
deg3npb:=Setseq({Place(c)+DD : c in pts, DD in deg2npb | not Place(c)+DD in deg3pbsum}) cat excpls;
bp:=2*Place(infcusp)+Place(cusp2);
bp2:=Place(infcusp)+Place(cusp2);
bp1:=Place(infcusp);

R<t> := PolynomialRing(Rationals());
K<a> := NumberField(R![-3, 1, -1, 1]);

for DDD in [excpls[2],excpls[3]] do
"Next point";
Pt := RepresentativePoint(Decomposition(DDD)[1][1]);
F := Parent(Pt[1]);
tf, phi := IsIsomorphic(F,K);
assert tf;
X(K)![phi(coef): coef in Eltseq(Pt)];
phi(j(Pt));
EPt := EllipticCurveFromjInvariant(j(Pt));
assert not HasComplexMultiplication(EPt);
L := NormalClosure(F);
GaloisConjugates :=[X(L)![sigma(coef): coef in Eltseq(Pt)]: sigma in Automorphisms(L)];
CondEPt := Conductor(EllipticCurveFromjInvariant(j(GaloisConjugates[1])));
assert &and[Parent(CondEPt) eq Parent(Conductor(EllipticCurveFromjInvariant(j(sigmaPt)))): sigmaPt in GaloisConjugates]; // sanity check
assert not &and[CondEPt eq Conductor(EllipticCurveFromjInvariant(j(sigmaPt))): sigmaPt in GaloisConjugates];
end for;

K<a> := NumberField(R![5, -3, -1, 1]);

for DDD in [excpls[1]] do
"Next point";
Pt := RepresentativePoint(Decomposition(DDD)[1][1]);
F := Parent(Pt[1]);
tf, phi := IsIsomorphic(F,K);
assert tf;
X(K)![phi(coef): coef in Eltseq(Pt)];
phi(j(Pt));
HasComplexMultiplication(EllipticCurveFromjInvariant(j(Pt)));
end for;



//Finally, we do the sieve.
A:=AbelianGroup([0,0,11]);
divs:=[D1,D2,Dtor];
genusC:=Genus(C);
auts:=[al[1]];
I:=2;
primes:=[q : q in PrimesUpTo(500) | q gt 300];
smallprimes:=[73,59,53,37,17,131,167,359];

/*
for p in primes do
    p;
    Fp:=GF(p); Fp2:=GF(p^2);
    Xp:=ChangeRing(X,Fp);
    CC,phi,psi:=ClassGroup(Xp);
    Z:=FreeAbelianGroup(1);
    degr:=hom<CC->Z | [ Degree(phi(a))*Z.1 : a in OrderedGenerators(CC)]>;
    JFp:=Kernel(degr); // This is isomorphic to J_X(\F_p).
    h:=hom<A -> JFp | [JFp!psi(reduce(X,Xp,D1)),JFp!psi(reduce(X,Xp,D2)),JFp!psi(reduce(X,Xp,Dtor))]>;
    m2:=hom<JFp -> JFp | [2*g : g in OrderedGenerators(JFp)]>;
    [h(A.1) in Image(m2),
    h(A.2) in Image(m2),
    h(A.1+A.2)in Image(m2)];
end for;
*/

load "Cubicsieve.m";

MWSieve(deg3pb,deg3npb,smallprimes,X,A,divs,auts,genusC,I,bp);
