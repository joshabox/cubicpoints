ALMap := function(X,auts)
R<[u]>:=CoordinateRing(AmbientSpace(X));
n:=Dimension(AmbientSpace(X)); //Assuming X is given in projective space
row:=[&+[RowSequence(auts[1])[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]]; 
//Note that this function is only called upon for N \neq 57 so #auts = 1
return iso<X -> X | row,row>;
end function;

IsOnlyWithFamily:=function(QQ,p,X,auts,genusC)
if p lt 14 then
return "p is not big enough";
end if;


//ptlist:=[];
d:=3;

QQDecomp := Decomposition(QQ);

if #QQDecomp eq 1 then
return false; //Our thm doesn't apply in this case
end if;

// Compute Atkin Lehner matrices in for X

eta := ALMap(X,auts);

// Find points we require and compute field of defintion

quadratic := false;
if #QQDecomp lt 3 then
ImportantPoints := QQDecomp;
for Div in ImportantPoints do
if Degree(ResidueClassField(Div[1])) gt 1 then
quadratic := true;
F := ResidueClassField(Div[1]);
K := QuadraticField(Discriminant(MaximalOrder(F)));
end if;
end for;

elif Pullback(eta,QQDecomp[1][1]) eq QQDecomp[2][1] then
ImportantPoints := [QQDecomp[1],QQDecomp[3]];
else
ImportantPoints := [QQDecomp[1],QQDecomp[2]];
end if;

if not(quadratic) then
K := RationalsAsNumberField();
if (#QQDecomp eq 2) and (Pullback(eta,QQDecomp[1][1]) eq QQDecomp[2][1])  then 
return false; //thm doesn't apply here - so we return false and look for another point to which it applies in the res disk
end if;
end if;

PointsToTest := [];

for Pt in ImportantPoints do
tf, emb := IsSubfield(ResidueClassField(Pt[1]),K);
PT := [emb(x) : x in Eltseq(RepresentativePoint(Pt[1]))];
Append(~PointsToTest,PT);
end for;

OK:=RingOfIntegers(K);
dec:=Factorization(p*OK);
pp:=dec[1][1];

// Compute ann. differentials of trace zero

Fp,OKRedMap:=ResidueClassField(pp); // was pi previously
Xp:=ChangeRing(X,Fp); //Depends on K 
Rp<[u]>:=CoordinateRing(AmbientSpace(Xp));
n:=Dimension(AmbientSpace(X)); //Assuming X is given in projective space
row:=[&+[RowSequence(auts[1])[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]]; 
//Note that this function is only called upon for N \neq 57 so #auts = 1
etap:=iso<Xp -> Xp | row,row>;

V,phi:=SpaceOfDifferentialsFirstKind(Xp);
t:=hom<V->V | [ (Pullback(etap,phi(V.i)))@@phi -V.i  : i in [1..Genus(X)] ]>;
T:=Image(t);
// if not p eq 2 then assert Dimension(T) eq Genus(X) - genusC; end if;
omegas:=[phi(T.i) : i in [1..Dimension(T)]];



unif:=UniformizingElement(pp);

Arows := [];
for Q in PointsToTest do
m:=Minimum([Valuation(a,pp) : a in Pt | not a eq 0]);
Qred:=[unif^(-m)*a : a in Q];
Qtilde:=Xp![Evaluate(a,Place(pp)) : a in Qred];
tQtilde:=UniformizingParameter(Qtilde);
Append(~Arows, [(omega/Differential(tQtilde))(Qtilde) : omega in omegas]);
end for;

Atilde:=Matrix(Arows);
if Rank(Atilde) eq #Arows then return true; 
else return false;
end if;
end function;
