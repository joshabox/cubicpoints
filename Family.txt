ALMap := function(X,auts)
R<[u]>:=CoordinateRing(AmbientSpace(X));
n:=Dimension(AmbientSpace(X)); //Assuming X is given in projective space
row:=[&+[RowSequence(auts[1])[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]]; 
//Note that this function is only called upon for N \neq 57 so #auts = 1
return iso<X -> X | row,row>;
end function;


IsOnlyWithFamily:=function(QQ,p,X,auts,genusC)
eta := ALMap(X,auts); // really we only need to comput this once
AwkwardDivisor := false;
if p lt 14 then
return "p is not big enough";
end if;


//ptlist:=[];
// d:=3;

QQDecomp := Decomposition(QQ);

//First case all points are rational and either all  equal or distinct
if #QQDecomp eq 1 then
AwkwardDivisor := true;
K:= RationalsAsNumberField();
ImportantPoints := QQDecomp;
end if;

if #QQDecomp eq 3 then
K := RationalsAsNumberField();
if QQDecomp[1][1] eq Pullback(eta,QQDecomp[2][1]) then
ImportantPoints := [QQDecomp[1],QQDecomp[3]];
else
ImportantPoints := QQDecomp[1][1] eq Pullback(eta,QQDecomp[3][1]) select [QQDecomp[1],QQDecomp[2]] else [QQDecomp[1],QQDecomp[3]];
end if;
end if;

// Second case have either a quadratic point or a  divisor of the form 2*Q + w(Q)
if #QQDecomp eq 2 then
quadratic := false;
for Div in QQDecomp do
if Degree(ResidueClassField(Div[1])) gt 1 then
ImportantPoints := QQDecomp;
F := ResidueClassField(Div[1]);
K := QuadraticField(Discriminant(MaximalOrder(F)));
quadratic := true;
end if;
end for;

if not(quadratic) then 
ImportantPoints := [(QQDecomp[1][2] eq 2) select QQDecomp[2] else QQDecomp[1]]; //Need to select w(Q)
K := RationalsAsNumberField();
AwkwardDivisor := true;
end if;
end if;



PointsToTest := [];

for Pt in ImportantPoints do
tf, emb := IsSubfield(ResidueClassField(Pt[1]),K);
PT := [emb(x) : x in Eltseq(RepresentativePoint(Pt[1]))];
Append(~PointsToTest,PT);
end for;

OK:=RingOfIntegers(K);
dec:=Factorization(p*OK);
pp:=dec[1][1];

// Compute ann. differentials of trace zero

Fp,OKRedMap:=ResidueClassField(pp); // was pi previously
Xp:=ChangeRing(X,Fp); //Depends on K 
Rp<[u]>:=CoordinateRing(AmbientSpace(Xp));
n:=Dimension(AmbientSpace(X)); //Assuming X is given in projective space
row:=[&+[RowSequence(auts[1])[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]]; 
//Note that this function is only called upon for N \neq 57 so #auts = 1
etap:=iso<Xp -> Xp | row,row>;

V,phi:=SpaceOfDifferentialsFirstKind(Xp);
t:=hom<V->V | [ (Pullback(etap,phi(V.i)))@@phi -V.i  : i in [1..Genus(X)] ]>;
T:=Image(t);
// if not p eq 2 then assert Dimension(T) eq Genus(X) - genusC; end if;
omegas:=[phi(T.i) : i in [1..Dimension(T)]];



unif:=UniformizingElement(pp);

Arows := [];

for Q in PointsToTest do
m:=Minimum([Valuation(a,pp) : a in Q | not a eq 0]);
Qred:=[unif^(-m)*a : a in Q];
Qtilde:=Xp![Evaluate(a,Place(pp)) : a in Qred];
tQtilde:=UniformizingParameter(Qtilde);
Append(~Arows,[(omega/Differential(tQtilde))(Qtilde) : omega in omegas]);
if AwkwardDivisor then
Append(~Arows,[((omega/Differential(tQtilde)-(omega/Differential(tQtilde))(Qtilde))/tQtilde)(Qtilde) : omega in omegas]);
end if;
end for;

Atilde:=Matrix(Arows);
if Rank(Atilde) eq #Arows then return true; 
else return false;
end if;
end function;
