ALMap := function(X,auts)
R<[u]>:=CoordinateRing(AmbientSpace(X));
n:=Dimension(AmbientSpace(X)); //Assuming X is given in projective space
row:=[&+[RowSequence(auts[1])[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]];
//Note that this function is only called upon for N \neq 57 so #auts = 1
return iso<X -> X | row,row>;
end function;

/* In the below ratpt should be given as Place(RationalPoint), pb a pullback and ratpts should contain a set of rational pts of X. 
For example, after loading "X065.m" the following should return "true"
IsOnlyWithFamily(Place(cusps[1]),deg2pb[1],19,X,[al[3]],Genus(C),cusps);
*/

IsOnlyWithFamily:=function(ratpt,pb,p,X,auts,genusC,ratpts)
if p lt 14 then
return "p is not big enough";
end if;
rationalpts := [Place(Pt) : Pt in ratpts];
eta := ALMap(X,auts); // really we only need to compute this once


// We first check if pb is a sum of rational pts
rational := false;
AwkwardDivisor := false;
n := #rationalpts;
for i in {x: x in CartesianProduct([{1 .. n},{1..n}])| x[1] le x[2]} do
if pb eq (rationalpts[i[1]]+ rationalpts[i[2]]) then
rational := true;
K := RationalsAsNumberField();
index := [Index(rationalpts, ratpt),i[1],i[2]];
break;
end if;
end for;

if rational then
  if Multiplicity(index,index[1]) eq 3 then
   ImportantPoints := [ratpt]; // need to select "w(Q)" (=Q here)
   AwkwardDivisor := true;
  elif (Multiplicity(index,index[1]) eq 2) then
   ImportantPoints := (Multiplicity(index,index[2]) eq 2) select [rationalpts[index[3]]] else  [rationalpts[index[2]]]; // need to select "w(Q)"
   AwkwardDivisor := true;
   assert Pullback(eta, ratpt) eq ImportantPoints[1]; // check we've selected "w(Q)"
  else
   ImportantPoints := [ratpt, rationalpts[index[2]]]; // all points are distinct, so we take ratpt and one of the points from the pullback
   assert (index[1]-index[2])*(index[1]-index[3])*(index[2]-index[3]) ne 0; //check
  end if;
else
 Decomp := Decomposition(pb); // decompose pullback
 ImportantPoints := [ratpt,Decomp[1][1]];
 F := ResidueClassField(Decomp[1][1]);
 K := QuadraticField(Discriminant(MaximalOrder(F)));
end if;


PointsToTest := [];

for Pt in ImportantPoints do
tf, emb := IsSubfield(ResidueClassField(Pt),K);
PT := [emb(x) : x in Eltseq(RepresentativePoint(Pt))];
Append(~PointsToTest,PT);
end for;

OK:=RingOfIntegers(K);
dec:=Factorization(p*OK);
pp:=dec[1][1];

// Compute ann. differentials of trace zero

Fp :=ResidueClassField(pp);
Xp:=ChangeRing(X,Fp); //Depends on K
Rp<[u]>:=CoordinateRing(AmbientSpace(Xp));
n:=Dimension(AmbientSpace(X)); //Assuming X is given in projective space
row:=[&+[RowSequence(auts[1])[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]];
//Note that this function is only called upon for N \neq 57 so #auts = 1
etap:=iso<Xp -> Xp | row,row>;

V,phi:=SpaceOfDifferentialsFirstKind(Xp);
t:=hom<V->V | [ (Pullback(etap,phi(V.i)))@@phi -V.i  : i in [1..Genus(X)] ]>;
T:=Image(t);
// if not p eq 2 then assert Dimension(T) eq Genus(X) - genusC; end if;
omegas:=[phi(T.i) : i in [1..Dimension(T)]];



unif:=UniformizingElement(pp);

Arows := [];

for Q in PointsToTest do
m:=Minimum([Valuation(a,pp) : a in Q | not a eq 0]);
Qred:=[unif^(-m)*a : a in Q];
Qtilde:=Xp![Evaluate(a,Place(pp)) : a in Qred];
tQtilde:=UniformizingParameter(Qtilde);
Append(~Arows,[(omega/Differential(tQtilde))(Qtilde) : omega in omegas]);
if AwkwardDivisor then
Append(~Arows,[((omega/Differential(tQtilde)-(omega/Differential(tQtilde))(Qtilde))/tQtilde)(Qtilde) : omega in omegas]);
end if;
end for;

Atilde:=Matrix(Arows);
if Rank(Atilde) eq #Arows then return true;
else return false;
end if;
end function;
